{
  "version": 3,
  "sources": ["../../three/examples/jsm/loaders/UltraHDRLoader.js"],
  "sourcesContent": ["import {\n\tClampToEdgeWrapping,\n\tDataTexture,\n\tDataUtils,\n\tFileLoader,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tRGBAFormat,\n\tUVMapping,\n} from 'three';\n\n/**\n * UltraHDR Image Format - https://developer.android.com/media/platform/hdr-image-format\n *\n * Short format brief:\n *\n *  [JPEG headers]\n *  [XMP metadata describing the MPF container and *both* SDR and gainmap images]\n *  [Optional metadata] [EXIF] [ICC Profile]\n *  [SDR image]\n *  [XMP metadata describing only the gainmap image]\n *  [Gainmap image]\n *\n * Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)\n * Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.\n */\n\n\n// Calculating this SRGB powers is extremely slow for 4K images and can be sufficiently precalculated for a 3-4x speed boost\nconst SRGB_TO_LINEAR = Array( 1024 )\n\t.fill( 0 )\n\t.map( ( _, value ) =>\n\t\tMath.pow( ( value / 255 ) * 0.9478672986 + 0.0521327014, 2.4 )\n\t);\n\n/**\n * A loader for the Ultra HDR Image Format.\n *\n * Existing HDR or EXR textures can be converted to Ultra HDR with this [tool]{@link https://gainmap-creator.monogrid.com/}.\n *\n * Current feature set:\n * - JPEG headers (required)\n * - XMP metadata (required)\n * - XMP validation (not implemented)\n * - EXIF profile (not implemented)\n * - ICC profile (not implemented)\n * - Binary storage for SDR & HDR images (required)\n * - Gainmap metadata (required)\n * - Non-JPEG image formats (not implemented)\n * - Primary image as an HDR image (not implemented)\n *\n * ```js\n * const loader = new UltraHDRLoader();\n * const texture = await loader.loadAsync( 'textures/equirectangular/ice_planet_close.jpg' );\n * texture.mapping = THREE.EquirectangularReflectionMapping;\n *\n * scene.background = texture;\n * scene.environment = texture;\n * ```\n *\n * @augments Loader\n * @three_import import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';\n */\nclass UltraHDRLoader extends Loader {\n\n\t/**\n\t * Constructs a new Ultra HDR loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * The texture type.\n\t\t *\n\t\t * @type {(HalfFloatType|FloatType)}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t/**\n\t * Sets the texture type.\n\t *\n\t * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n\t * @return {RGBELoader} A reference to this loader.\n\t */\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given Ultra HDR texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @param {Function} onLoad - The `onLoad` callback.\n\t */\n\tparse( buffer, onLoad ) {\n\n\t\tconst xmpMetadata = {\n\t\t\tversion: null,\n\t\t\tbaseRenditionIsHDR: null,\n\t\t\tgainMapMin: null,\n\t\t\tgainMapMax: null,\n\t\t\tgamma: null,\n\t\t\toffsetSDR: null,\n\t\t\toffsetHDR: null,\n\t\t\thdrCapacityMin: null,\n\t\t\thdrCapacityMax: null,\n\t\t};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tconst data = new DataView( buffer );\n\n\t\tlet byteOffset = 0;\n\t\tconst sections = [];\n\n\t\twhile ( byteOffset < data.byteLength ) {\n\n\t\t\tconst byte = data.getUint8( byteOffset );\n\n\t\t\tif ( byte === 0xff ) {\n\n\t\t\t\tconst leadingByte = data.getUint8( byteOffset + 1 );\n\n\t\t\t\tif (\n\t\t\t\t\t[\n\t\t\t\t\t\t/* Valid section headers */\n\t\t\t\t\t\t0xd8, // SOI\n\t\t\t\t\t\t0xe0, // APP0\n\t\t\t\t\t\t0xe1, // APP1\n\t\t\t\t\t\t0xe2, // APP2\n\t\t\t\t\t].includes( leadingByte )\n\t\t\t\t) {\n\n\t\t\t\t\tsections.push( {\n\t\t\t\t\t\tsectionType: leadingByte,\n\t\t\t\t\t\tsection: [ byte, leadingByte ],\n\t\t\t\t\t\tsectionOffset: byteOffset + 2,\n\t\t\t\t\t} );\n\n\t\t\t\t\tbyteOffset += 2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsections[ sections.length - 1 ].section.push( byte, leadingByte );\n\n\t\t\t\t\tbyteOffset += 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsections[ sections.length - 1 ].section.push( byte );\n\n\t\t\t\tbyteOffset ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet primaryImage, gainmapImage;\n\n\t\tfor ( let i = 0; i < sections.length; i ++ ) {\n\n\t\t\tconst { sectionType, section, sectionOffset } = sections[ i ];\n\n\t\t\tif ( sectionType === 0xe0 ) {\n\t\t\t\t/* JPEG Header - no useful information */\n\t\t\t} else if ( sectionType === 0xe1 ) {\n\n\t\t\t\t/* XMP Metadata */\n\n\t\t\t\tthis._parseXMPMetadata(\n\t\t\t\t\ttextDecoder.decode( new Uint8Array( section ) ),\n\t\t\t\t\txmpMetadata\n\t\t\t\t);\n\n\t\t\t} else if ( sectionType === 0xe2 ) {\n\n\t\t\t\t/* Data Sections - MPF / EXIF / ICC Profile */\n\n\t\t\t\tconst sectionData = new DataView(\n\t\t\t\t\tnew Uint8Array( section.slice( 2 ) ).buffer\n\t\t\t\t);\n\t\t\t\tconst sectionHeader = sectionData.getUint32( 2, false );\n\n\t\t\t\tif ( sectionHeader === 0x4d504600 ) {\n\n\t\t\t\t\t/* MPF Section */\n\n\t\t\t\t\t/* Section contains a list of static bytes and ends with offsets indicating location of SDR and gainmap images */\n\t\t\t\t\t/* First bytes after header indicate little / big endian ordering (0x49492A00 - LE / 0x4D4D002A - BE) */\n\t\t\t\t\t/*\n\t\t\t\t\t... 60 bytes indicating tags, versions, etc. ...\n\n\t\t\t\t\tbytes | bits | description\n\n\t\t\t\t\t4       32     primary image size\n\t\t\t\t\t4       32     primary image offset\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t2       16     0x0000\n\n\t\t\t\t\t4       32     0x00000000\n\t\t\t\t\t4       32     gainmap image size\n\t\t\t\t\t4       32     gainmap image offset\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t*/\n\n\t\t\t\t\tconst mpfLittleEndian = sectionData.getUint32( 6 ) === 0x49492a00;\n\t\t\t\t\tconst mpfBytesOffset = 60;\n\n\t\t\t\t\t/* SDR size includes the metadata length, SDR offset is always 0 */\n\n\t\t\t\t\tconst primaryImageSize = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\t\t\t\t\tconst primaryImageOffset = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset + 4,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\n\t\t\t\t\t/* Gainmap size is an absolute value starting from its offset, gainmap offset needs 6 bytes padding to take into account 0x00 bytes at the end of XMP */\n\t\t\t\t\tconst gainmapImageSize = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset + 16,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\t\t\t\t\tconst gainmapImageOffset =\n\t\t\t\t\t\tsectionData.getUint32( mpfBytesOffset + 20, mpfLittleEndian ) +\n\t\t\t\t\t\tsectionOffset +\n\t\t\t\t\t\t6;\n\n\t\t\t\t\tprimaryImage = new Uint8Array(\n\t\t\t\t\t\tdata.buffer,\n\t\t\t\t\t\tprimaryImageOffset,\n\t\t\t\t\t\tprimaryImageSize\n\t\t\t\t\t);\n\n\t\t\t\t\tgainmapImage = new Uint8Array(\n\t\t\t\t\t\tdata.buffer,\n\t\t\t\t\t\tgainmapImageOffset,\n\t\t\t\t\t\tgainmapImageSize\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Minimal sufficient validation - https://developer.android.com/media/platform/hdr-image-format#signal_of_the_format */\n\t\tif ( ! xmpMetadata.version ) {\n\n\t\t\tthrow new Error( 'THREE.UltraHDRLoader: Not a valid UltraHDR image' );\n\n\t\t}\n\n\t\tif ( primaryImage && gainmapImage ) {\n\n\t\t\tthis._applyGainmapToSDR(\n\t\t\t\txmpMetadata,\n\t\t\t\tprimaryImage,\n\t\t\t\tgainmapImage,\n\t\t\t\t( hdrBuffer, width, height ) => {\n\n\t\t\t\t\tonLoad( {\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tdata: hdrBuffer,\n\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\ttype: this.type,\n\t\t\t\t\t} );\n\n\t\t\t\t},\n\t\t\t\t( error ) => {\n\n\t\t\t\t\tthrow new Error( error );\n\n\t\t\t\t}\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.UltraHDRLoader: Could not parse UltraHDR images' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded Ultra HDR texture\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the files to be loaded. This can also be a data URI.\n\t * @param {function(DataTexture, Object)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t * @return {DataTexture} The Ultra HDR texture.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new DataTexture(\n\t\t\tthis.type === HalfFloatType ? new Uint16Array() : new Float32Array(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tRGBAFormat,\n\t\t\tthis.type,\n\t\t\tUVMapping,\n\t\t\tClampToEdgeWrapping,\n\t\t\tClampToEdgeWrapping,\n\t\t\tLinearFilter,\n\t\t\tLinearMipMapLinearFilter,\n\t\t\t1,\n\t\t\tLinearSRGBColorSpace\n\t\t);\n\t\ttexture.generateMipmaps = true;\n\t\ttexture.flipY = true;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\ttry {\n\n\t\t\t\tthis.parse(\n\t\t\t\t\tbuffer,\n\t\t\t\t\t( texData ) => {\n\n\t\t\t\t\t\ttexture.image = {\n\t\t\t\t\t\t\tdata: texData.data,\n\t\t\t\t\t\t\twidth: texData.width,\n\t\t\t\t\t\t\theight: texData.height,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n\t_parseXMPMetadata( xmpDataString, xmpMetadata ) {\n\n\t\tconst domParser = new DOMParser();\n\n\t\tconst xmpXml = domParser.parseFromString(\n\t\t\txmpDataString.substring(\n\t\t\t\txmpDataString.indexOf( '<' ),\n\t\t\t\txmpDataString.lastIndexOf( '>' ) + 1\n\t\t\t),\n\t\t\t'text/xml'\n\t\t);\n\n\t\t/* Determine if given XMP metadata is the primary GContainer descriptor or a gainmap descriptor */\n\t\tconst [ hasHDRContainerDescriptor ] = xmpXml.getElementsByTagName(\n\t\t\t'Container:Directory'\n\t\t);\n\n\t\tif ( hasHDRContainerDescriptor ) {\n\t\t\t/* There's not much useful information in the container descriptor besides memory-validation */\n\t\t} else {\n\n\t\t\t/* Gainmap descriptor - defaults from https://developer.android.com/media/platform/hdr-image-format#HDR_gain_map_metadata */\n\n\t\t\tconst [ gainmapNode ] = xmpXml.getElementsByTagName( 'rdf:Description' );\n\n\t\t\txmpMetadata.version = gainmapNode.getAttribute( 'hdrgm:Version' );\n\t\t\txmpMetadata.baseRenditionIsHDR =\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:BaseRenditionIsHDR' ) === 'True';\n\t\t\txmpMetadata.gainMapMin = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:GainMapMin' ) || 0.0\n\t\t\t);\n\t\t\txmpMetadata.gainMapMax = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:GainMapMax' ) || 1.0\n\t\t\t);\n\t\t\txmpMetadata.gamma = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:Gamma' ) || 1.0\n\t\t\t);\n\t\t\txmpMetadata.offsetSDR = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:OffsetSDR' ) / ( 1 / 64 )\n\t\t\t);\n\t\t\txmpMetadata.offsetHDR = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:OffsetHDR' ) / ( 1 / 64 )\n\t\t\t);\n\t\t\txmpMetadata.hdrCapacityMin = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:HDRCapacityMin' ) || 0.0\n\t\t\t);\n\t\t\txmpMetadata.hdrCapacityMax = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:HDRCapacityMax' ) || 1.0\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t_srgbToLinear( value ) {\n\n\t\tif ( value / 255 < 0.04045 ) {\n\n\t\t\treturn ( value / 255 ) * 0.0773993808;\n\n\t\t}\n\n\t\tif ( value < 1024 ) {\n\n\t\t\treturn SRGB_TO_LINEAR[ ~ ~ value ];\n\n\t\t}\n\n\t\treturn Math.pow( ( value / 255 ) * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t}\n\n\t_applyGainmapToSDR(\n\t\txmpMetadata,\n\t\tsdrBuffer,\n\t\tgainmapBuffer,\n\t\tonSuccess,\n\t\tonError\n\t) {\n\n\t\tconst getImageDataFromBuffer = ( buffer ) =>\n\t\t\tnew Promise( ( resolve, reject ) => {\n\n\t\t\t\tconst imageLoader = document.createElement( 'img' );\n\n\t\t\t\timageLoader.onload = () => {\n\n\t\t\t\t\tconst image = {\n\t\t\t\t\t\twidth: imageLoader.naturalWidth,\n\t\t\t\t\t\theight: imageLoader.naturalHeight,\n\t\t\t\t\t\tsource: imageLoader,\n\t\t\t\t\t};\n\n\t\t\t\t\tURL.revokeObjectURL( imageLoader.src );\n\n\t\t\t\t\tresolve( image );\n\n\t\t\t\t};\n\n\t\t\t\timageLoader.onerror = () => {\n\n\t\t\t\t\tURL.revokeObjectURL( imageLoader.src );\n\n\t\t\t\t\treject();\n\n\t\t\t\t};\n\n\t\t\t\timageLoader.src = URL.createObjectURL(\n\t\t\t\t\tnew Blob( [ buffer ], { type: 'image/jpeg' } )\n\t\t\t\t);\n\n\t\t\t} );\n\n\t\tPromise.all( [\n\t\t\tgetImageDataFromBuffer( sdrBuffer ),\n\t\t\tgetImageDataFromBuffer( gainmapBuffer ),\n\t\t] )\n\t\t\t.then( ( [ sdrImage, gainmapImage ] ) => {\n\n\t\t\t\tconst sdrImageAspect = sdrImage.width / sdrImage.height;\n\t\t\t\tconst gainmapImageAspect = gainmapImage.width / gainmapImage.height;\n\n\t\t\t\tif ( sdrImageAspect !== gainmapImageAspect ) {\n\n\t\t\t\t\tonError(\n\t\t\t\t\t\t'THREE.UltraHDRLoader Error: Aspect ratio mismatch between SDR and Gainmap images'\n\t\t\t\t\t);\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tconst ctx = canvas.getContext( '2d', {\n\t\t\t\t\twillReadFrequently: true,\n\t\t\t\t\tcolorSpace: 'srgb',\n\t\t\t\t} );\n\n\t\t\t\tcanvas.width = sdrImage.width;\n\t\t\t\tcanvas.height = sdrImage.height;\n\n\t\t\t\t/* Use out-of-the-box interpolation of Canvas API to scale gainmap to fit the SDR resolution */\n\t\t\t\tctx.drawImage(\n\t\t\t\t\tgainmapImage.source,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tgainmapImage.width,\n\t\t\t\t\tgainmapImage.height,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height\n\t\t\t\t);\n\t\t\t\tconst gainmapImageData = ctx.getImageData(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height,\n\t\t\t\t\t{ colorSpace: 'srgb' }\n\t\t\t\t);\n\n\t\t\t\tctx.drawImage( sdrImage.source, 0, 0 );\n\t\t\t\tconst sdrImageData = ctx.getImageData(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height,\n\t\t\t\t\t{ colorSpace: 'srgb' }\n\t\t\t\t);\n\n\t\t\t\t/* HDR Recovery formula - https://developer.android.com/media/platform/hdr-image-format#use_the_gain_map_to_create_adapted_HDR_rendition */\n\t\t\t\tlet hdrBuffer;\n\n\t\t\t\tif ( this.type === HalfFloatType ) {\n\n\t\t\t\t\thdrBuffer = new Uint16Array( sdrImageData.data.length ).fill( 23544 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\thdrBuffer = new Float32Array( sdrImageData.data.length ).fill( 255 );\n\n\t\t\t\t}\n\n\t\t\t\tconst maxDisplayBoost = Math.sqrt(\n\t\t\t\t\tMath.pow(\n\t\t\t\t\t\t/* 1.8 instead of 2 near-perfectly rectifies approximations introduced by precalculated SRGB_TO_LINEAR values */\n\t\t\t\t\t\t1.8,\n\t\t\t\t\t\txmpMetadata.hdrCapacityMax\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tconst unclampedWeightFactor =\n\t\t\t\t\t( Math.log2( maxDisplayBoost ) - xmpMetadata.hdrCapacityMin ) /\n\t\t\t\t\t( xmpMetadata.hdrCapacityMax - xmpMetadata.hdrCapacityMin );\n\t\t\t\tconst weightFactor = Math.min(\n\t\t\t\t\tMath.max( unclampedWeightFactor, 0.0 ),\n\t\t\t\t\t1.0\n\t\t\t\t);\n\t\t\t\tconst useGammaOne = xmpMetadata.gamma === 1.0;\n\n\t\t\t\tfor (\n\t\t\t\t\tlet pixelIndex = 0;\n\t\t\t\t\tpixelIndex < sdrImageData.data.length;\n\t\t\t\t\tpixelIndex += 4\n\t\t\t\t) {\n\n\t\t\t\t\tconst x = ( pixelIndex / 4 ) % sdrImage.width;\n\t\t\t\t\tconst y = Math.floor( pixelIndex / 4 / sdrImage.width );\n\n\t\t\t\t\tfor ( let channelIndex = 0; channelIndex < 3; channelIndex ++ ) {\n\n\t\t\t\t\t\tconst sdrValue = sdrImageData.data[ pixelIndex + channelIndex ];\n\n\t\t\t\t\t\tconst gainmapIndex = ( y * sdrImage.width + x ) * 4 + channelIndex;\n\t\t\t\t\t\tconst gainmapValue = gainmapImageData.data[ gainmapIndex ] / 255.0;\n\n\t\t\t\t\t\t/* Gamma is 1.0 by default */\n\t\t\t\t\t\tconst logRecovery = useGammaOne\n\t\t\t\t\t\t\t? gainmapValue\n\t\t\t\t\t\t\t: Math.pow( gainmapValue, 1.0 / xmpMetadata.gamma );\n\n\t\t\t\t\t\tconst logBoost =\n\t\t\t\t\t\t\txmpMetadata.gainMapMin * ( 1.0 - logRecovery ) +\n\t\t\t\t\t\t\txmpMetadata.gainMapMax * logRecovery;\n\n\t\t\t\t\t\tconst hdrValue =\n\t\t\t\t\t\t\t( sdrValue + xmpMetadata.offsetSDR ) *\n\t\t\t\t\t\t\t\t( logBoost * weightFactor === 0.0\n\t\t\t\t\t\t\t\t\t? 1.0\n\t\t\t\t\t\t\t\t\t: Math.pow( 2, logBoost * weightFactor ) ) -\n\t\t\t\t\t\t\txmpMetadata.offsetHDR;\n\n\t\t\t\t\t\tconst linearHDRValue = Math.min(\n\t\t\t\t\t\t\tMath.max( this._srgbToLinear( hdrValue ), 0 ),\n\t\t\t\t\t\t\t65504\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\thdrBuffer[ pixelIndex + channelIndex ] =\n\t\t\t\t\t\t\tthis.type === HalfFloatType\n\t\t\t\t\t\t\t\t? DataUtils.toHalfFloat( linearHDRValue )\n\t\t\t\t\t\t\t\t: linearHDRValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tonSuccess( hdrBuffer, sdrImage.width, sdrImage.height );\n\n\t\t\t} )\n\t\t\t.catch( () => {\n\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'THREE.UltraHDRLoader Error: Could not parse UltraHDR images'\n\t\t\t\t);\n\n\t\t\t} );\n\n\t}\n\n}\n\nexport { UltraHDRLoader };\n"],
  "mappings": "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",
  "names": []
}
