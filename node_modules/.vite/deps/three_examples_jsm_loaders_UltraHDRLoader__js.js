import {
  ClampToEdgeWrapping,
  DataTexture,
  DataUtils,
  FileLoader,
  HalfFloatType,
  LinearFilter,
  LinearMipMapLinearFilter,
  LinearSRGBColorSpace,
  Loader,
  RGBAFormat,
  UVMapping
} from "./chunk-5MKLNLKQ.js";

// node_modules/three/examples/jsm/loaders/UltraHDRLoader.js
var SRGB_TO_LINEAR = Array(1024).fill(0).map(
  (_, value) => Math.pow(value / 255 * 0.9478672986 + 0.0521327014, 2.4)
);
var UltraHDRLoader = class extends Loader {
  /**
   * Constructs a new Ultra HDR loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  /**
   * Sets the texture type.
   *
   * @param {(HalfFloatType|FloatType)} value - The texture type to set.
   * @return {RGBELoader} A reference to this loader.
   */
  setDataType(value) {
    this.type = value;
    return this;
  }
  /**
   * Parses the given Ultra HDR texture data.
   *
   * @param {ArrayBuffer} buffer - The raw texture data.
   * @param {Function} onLoad - The `onLoad` callback.
   */
  parse(buffer, onLoad) {
    const xmpMetadata = {
      version: null,
      baseRenditionIsHDR: null,
      gainMapMin: null,
      gainMapMax: null,
      gamma: null,
      offsetSDR: null,
      offsetHDR: null,
      hdrCapacityMin: null,
      hdrCapacityMax: null
    };
    const textDecoder = new TextDecoder();
    const data = new DataView(buffer);
    let byteOffset = 0;
    const sections = [];
    while (byteOffset < data.byteLength) {
      const byte = data.getUint8(byteOffset);
      if (byte === 255) {
        const leadingByte = data.getUint8(byteOffset + 1);
        if ([
          /* Valid section headers */
          216,
          // SOI
          224,
          // APP0
          225,
          // APP1
          226
          // APP2
        ].includes(leadingByte)) {
          sections.push({
            sectionType: leadingByte,
            section: [byte, leadingByte],
            sectionOffset: byteOffset + 2
          });
          byteOffset += 2;
        } else {
          sections[sections.length - 1].section.push(byte, leadingByte);
          byteOffset += 2;
        }
      } else {
        sections[sections.length - 1].section.push(byte);
        byteOffset++;
      }
    }
    let primaryImage, gainmapImage;
    for (let i = 0; i < sections.length; i++) {
      const { sectionType, section, sectionOffset } = sections[i];
      if (sectionType === 224) {
      } else if (sectionType === 225) {
        this._parseXMPMetadata(
          textDecoder.decode(new Uint8Array(section)),
          xmpMetadata
        );
      } else if (sectionType === 226) {
        const sectionData = new DataView(
          new Uint8Array(section.slice(2)).buffer
        );
        const sectionHeader = sectionData.getUint32(2, false);
        if (sectionHeader === 1297106432) {
          const mpfLittleEndian = sectionData.getUint32(6) === 1229531648;
          const mpfBytesOffset = 60;
          const primaryImageSize = sectionData.getUint32(
            mpfBytesOffset,
            mpfLittleEndian
          );
          const primaryImageOffset = sectionData.getUint32(
            mpfBytesOffset + 4,
            mpfLittleEndian
          );
          const gainmapImageSize = sectionData.getUint32(
            mpfBytesOffset + 16,
            mpfLittleEndian
          );
          const gainmapImageOffset = sectionData.getUint32(mpfBytesOffset + 20, mpfLittleEndian) + sectionOffset + 6;
          primaryImage = new Uint8Array(
            data.buffer,
            primaryImageOffset,
            primaryImageSize
          );
          gainmapImage = new Uint8Array(
            data.buffer,
            gainmapImageOffset,
            gainmapImageSize
          );
        }
      }
    }
    if (!xmpMetadata.version) {
      throw new Error("THREE.UltraHDRLoader: Not a valid UltraHDR image");
    }
    if (primaryImage && gainmapImage) {
      this._applyGainmapToSDR(
        xmpMetadata,
        primaryImage,
        gainmapImage,
        (hdrBuffer, width, height) => {
          onLoad({
            width,
            height,
            data: hdrBuffer,
            format: RGBAFormat,
            type: this.type
          });
        },
        (error) => {
          throw new Error(error);
        }
      );
    } else {
      throw new Error("THREE.UltraHDRLoader: Could not parse UltraHDR images");
    }
  }
  /**
   * Starts loading from the given URL and passes the loaded Ultra HDR texture
   * to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the files to be loaded. This can also be a data URI.
   * @param {function(DataTexture, Object)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {DataTexture} The Ultra HDR texture.
   */
  load(url, onLoad, onProgress, onError) {
    const texture = new DataTexture(
      this.type === HalfFloatType ? new Uint16Array() : new Float32Array(),
      0,
      0,
      RGBAFormat,
      this.type,
      UVMapping,
      ClampToEdgeWrapping,
      ClampToEdgeWrapping,
      LinearFilter,
      LinearMipMapLinearFilter,
      1,
      LinearSRGBColorSpace
    );
    texture.generateMipmaps = true;
    texture.flipY = true;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      try {
        this.parse(
          buffer,
          (texData) => {
            texture.image = {
              data: texData.data,
              width: texData.width,
              height: texData.height
            };
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
          }
        );
      } catch (error) {
        if (onError) onError(error);
        console.error(error);
      }
    }, onProgress, onError);
    return texture;
  }
  _parseXMPMetadata(xmpDataString, xmpMetadata) {
    const domParser = new DOMParser();
    const xmpXml = domParser.parseFromString(
      xmpDataString.substring(
        xmpDataString.indexOf("<"),
        xmpDataString.lastIndexOf(">") + 1
      ),
      "text/xml"
    );
    const [hasHDRContainerDescriptor] = xmpXml.getElementsByTagName(
      "Container:Directory"
    );
    if (hasHDRContainerDescriptor) {
    } else {
      const [gainmapNode] = xmpXml.getElementsByTagName("rdf:Description");
      xmpMetadata.version = gainmapNode.getAttribute("hdrgm:Version");
      xmpMetadata.baseRenditionIsHDR = gainmapNode.getAttribute("hdrgm:BaseRenditionIsHDR") === "True";
      xmpMetadata.gainMapMin = parseFloat(
        gainmapNode.getAttribute("hdrgm:GainMapMin") || 0
      );
      xmpMetadata.gainMapMax = parseFloat(
        gainmapNode.getAttribute("hdrgm:GainMapMax") || 1
      );
      xmpMetadata.gamma = parseFloat(
        gainmapNode.getAttribute("hdrgm:Gamma") || 1
      );
      xmpMetadata.offsetSDR = parseFloat(
        gainmapNode.getAttribute("hdrgm:OffsetSDR") / (1 / 64)
      );
      xmpMetadata.offsetHDR = parseFloat(
        gainmapNode.getAttribute("hdrgm:OffsetHDR") / (1 / 64)
      );
      xmpMetadata.hdrCapacityMin = parseFloat(
        gainmapNode.getAttribute("hdrgm:HDRCapacityMin") || 0
      );
      xmpMetadata.hdrCapacityMax = parseFloat(
        gainmapNode.getAttribute("hdrgm:HDRCapacityMax") || 1
      );
    }
  }
  _srgbToLinear(value) {
    if (value / 255 < 0.04045) {
      return value / 255 * 0.0773993808;
    }
    if (value < 1024) {
      return SRGB_TO_LINEAR[~~value];
    }
    return Math.pow(value / 255 * 0.9478672986 + 0.0521327014, 2.4);
  }
  _applyGainmapToSDR(xmpMetadata, sdrBuffer, gainmapBuffer, onSuccess, onError) {
    const getImageDataFromBuffer = (buffer) => new Promise((resolve, reject) => {
      const imageLoader = document.createElement("img");
      imageLoader.onload = () => {
        const image = {
          width: imageLoader.naturalWidth,
          height: imageLoader.naturalHeight,
          source: imageLoader
        };
        URL.revokeObjectURL(imageLoader.src);
        resolve(image);
      };
      imageLoader.onerror = () => {
        URL.revokeObjectURL(imageLoader.src);
        reject();
      };
      imageLoader.src = URL.createObjectURL(
        new Blob([buffer], { type: "image/jpeg" })
      );
    });
    Promise.all([
      getImageDataFromBuffer(sdrBuffer),
      getImageDataFromBuffer(gainmapBuffer)
    ]).then(([sdrImage, gainmapImage]) => {
      const sdrImageAspect = sdrImage.width / sdrImage.height;
      const gainmapImageAspect = gainmapImage.width / gainmapImage.height;
      if (sdrImageAspect !== gainmapImageAspect) {
        onError(
          "THREE.UltraHDRLoader Error: Aspect ratio mismatch between SDR and Gainmap images"
        );
        return;
      }
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", {
        willReadFrequently: true,
        colorSpace: "srgb"
      });
      canvas.width = sdrImage.width;
      canvas.height = sdrImage.height;
      ctx.drawImage(
        gainmapImage.source,
        0,
        0,
        gainmapImage.width,
        gainmapImage.height,
        0,
        0,
        sdrImage.width,
        sdrImage.height
      );
      const gainmapImageData = ctx.getImageData(
        0,
        0,
        sdrImage.width,
        sdrImage.height,
        { colorSpace: "srgb" }
      );
      ctx.drawImage(sdrImage.source, 0, 0);
      const sdrImageData = ctx.getImageData(
        0,
        0,
        sdrImage.width,
        sdrImage.height,
        { colorSpace: "srgb" }
      );
      let hdrBuffer;
      if (this.type === HalfFloatType) {
        hdrBuffer = new Uint16Array(sdrImageData.data.length).fill(23544);
      } else {
        hdrBuffer = new Float32Array(sdrImageData.data.length).fill(255);
      }
      const maxDisplayBoost = Math.sqrt(
        Math.pow(
          /* 1.8 instead of 2 near-perfectly rectifies approximations introduced by precalculated SRGB_TO_LINEAR values */
          1.8,
          xmpMetadata.hdrCapacityMax
        )
      );
      const unclampedWeightFactor = (Math.log2(maxDisplayBoost) - xmpMetadata.hdrCapacityMin) / (xmpMetadata.hdrCapacityMax - xmpMetadata.hdrCapacityMin);
      const weightFactor = Math.min(
        Math.max(unclampedWeightFactor, 0),
        1
      );
      const useGammaOne = xmpMetadata.gamma === 1;
      for (let pixelIndex = 0; pixelIndex < sdrImageData.data.length; pixelIndex += 4) {
        const x = pixelIndex / 4 % sdrImage.width;
        const y = Math.floor(pixelIndex / 4 / sdrImage.width);
        for (let channelIndex = 0; channelIndex < 3; channelIndex++) {
          const sdrValue = sdrImageData.data[pixelIndex + channelIndex];
          const gainmapIndex = (y * sdrImage.width + x) * 4 + channelIndex;
          const gainmapValue = gainmapImageData.data[gainmapIndex] / 255;
          const logRecovery = useGammaOne ? gainmapValue : Math.pow(gainmapValue, 1 / xmpMetadata.gamma);
          const logBoost = xmpMetadata.gainMapMin * (1 - logRecovery) + xmpMetadata.gainMapMax * logRecovery;
          const hdrValue = (sdrValue + xmpMetadata.offsetSDR) * (logBoost * weightFactor === 0 ? 1 : Math.pow(2, logBoost * weightFactor)) - xmpMetadata.offsetHDR;
          const linearHDRValue = Math.min(
            Math.max(this._srgbToLinear(hdrValue), 0),
            65504
          );
          hdrBuffer[pixelIndex + channelIndex] = this.type === HalfFloatType ? DataUtils.toHalfFloat(linearHDRValue) : linearHDRValue;
        }
      }
      onSuccess(hdrBuffer, sdrImage.width, sdrImage.height);
    }).catch(() => {
      throw new Error(
        "THREE.UltraHDRLoader Error: Could not parse UltraHDR images"
      );
    });
  }
};
export {
  UltraHDRLoader
};
//# sourceMappingURL=three_examples_jsm_loaders_UltraHDRLoader__js.js.map
